= Административни неща

* Clojure курс, в който целим да grok-нете езика
* Вторник (200) и Четвъртък (200) от 19:00
* Сайтът ни е [fmi.clojure.bg](http://fmi.clojure.bg/) ­ регистрирайте се скоропостижно
* Имаме [Facebook група](https://www.facebook.com/groups/clojure.fmi/) и [Twitter потребител](https://twitter.com/clojurefmi)
* Кодът на лекциите е в GitHub ([gh:fmi/clojure-lectures]), а всеки одобрен pull request ви носи точки

= Административни неща (2)

* Курсът тази година ще е по-лек
* Ще ви занимаваме с доста домашни и предизвикателства
* Ако идвате само за кредити и оценка, по-добре отпишете
* Основно лекции ─ нямаме упражнения
* Присъствието е силно препоръчително (така ще ви е доста по-лесно)
* Всичко се върти около сайта на курса и присъствие на лекциите

= Добри новини (за изостаналите)
== или как да изкарате първите си 3 точки

* Сложете си снимка на сайта
* Инсталирайте си Clojure и качете screenshot на форумите
* Представете се на форумите

= Днес

* За Clojure на кратко
* Разходка по основните идеи
* Основни функции
* Вектори
* Как да си намерим документация и още материали

= Да си припомним

* Динамичен език
* Модерен диалект на Lisp
* Дизайннат да се хоства в друг език
* Основните имплементации са за JVM и JavaScript
* Негов автор е [Rich Hickey](http://www.infoq.com/author/Rich-Hickey)

= Типове и примитиви

* числа – `1`, `3.14`
* текстови символи (characters) – `\n`, `\i`
* низове – `"chunky bacon"`
* истина и лъжа – `true`, `false`
* `nil`
* вектори – `[2 3 5 7 11]`
* мапове – `{:name "Jesus", :age 33}`
* множества – `#{:apples "oranges" :pears}`
* списъци – `'("a" "list" "of strings")`
* регулярни изрази – `#"bb|[^b]{2}"`
* ключови думи – `:location`
* символи – `'name`
* запетаята не значи нищо, като whitespace е

= Операции

:annotate
  (+ 1 3)                  ; =>
  (- 7 4)                  ; =>
  (/ 9 3)                  ; =>
  (* 3 5)                  ; =>
  (/ 64 (- (+ 7 4) 3))     ; =>

  (inc 3)                  ; =>
  (dec 3)                  ; =>

  (= 0 0)                  ; =>
  (> 0 -1)                 ; =>
  (< 0 -1)                 ; =>
  (>= 0 -1)                ; =>
  (<= 0 -1)                ; =>

= Операции (2)

:annotate
  (pos? -1)                ; =>
  (neg? -1)                ; =>
  (zero? 0)                ; =>

  (not true)               ; =>
  (or true false)          ; =>
  (and true false)         ; =>

  (str "Hello, " "world!") ; =>

= Променливи
== или по-скоро – дефиниции

:code
  (def PI 3.14)
  (def lang "Clojure")

* Даваме име на нещо
* Винаги са глобални за текущия `namespace`
* `def` не се ползва във функции

= Функции

:annotate
  (defn sum [x y]
    (+ x y))

  (sum 1 2)       ; =>
  (sum 2 (* 3 5)) ; =>

= Условия

:code
  (if (> x y)
    (print "x > y")
    (print "x < y"))

= Локални дефиниции

:annotate
  (let [x 10
        y (+ x 5)]
    (+ x y)) ; =>

* Валидни само за тялото на `let`
* Не можем да променяме значението им
* Аргументите на функциите също са локални дефиниции

= Пространства от имена

:code
  (ns project.core)
  (defn sum [x y] (+ x y))

  (sum 3 4)
  (project.core/sum 3 4)

  ;; -----------------------------------------

  (ns project.core
    (:require clojure.string))

  (clojure.string/upper-case "batman")

* Мястото, където живеят всички дефиниции
* По едно на файл
* Пише се най-отгоре

= Примери
== Факториел

:annotate
  (defn factorial[x]
    (if (<= x 1)
      1
      (* x (factorial (dec x)))))

  (factorial 1) ; =>
  (factorial 6) ; =>

= Примери
== Фибоначи

:annotate
  (defn fib [n]
    (if (<= 0 n 1)
        1
        (+ (fib (- n 1))
           (fib (- n 2)))))

  (fib 0)  ; =>
  (fib 11) ; =>

= Примери
== Изводи

* Ще ползваме доста рекурсия
* Това е начина да избегнем mutability-то
* ...което е най-основен принцип в Clojure
* Ще видим как това е причината да е възможно почти всичко интересно в езика

= Какво забелязваме в синтаксиса

* Скобите са на необичайните места
* Скобите изглеждат повече
* Скобите са дори на места, където по принцип няма нужда
* ...хората винаги забелязват скобите

= Какво не забелязваме в синтаксиса

* Прост
* Компактен (почти няма синтаксис)
* Консистентен
* Липсва многословието, което забелязваме в други езици

= Какво не забелязваме в синтаксиса

:annotate
  ;; Умножение на 2 числа
  (* 3 5)         ; =>

  ;; Списък, в който има един символ и 2 числа
  (quote (* 3 5)) ; =>
  '(* 3 5)        ; =>

= Сравнение
== JavaScript код

{{{
<pre>
function abs(x) {
  if (x > 0) {
    return x;
  } else {
    return x * -1;
  }
}

abs(-1);
</pre>
}}}

= Сравнение
== Clojure форми

:code

  (defn abs [x]
    (if (> 0 x)
      x
      (* x -1)))

  (abs -1)

* Липсват неща като <code>;</code>, `return` и `else`
* Структурно валиден код наричаме Clojure форма

= Още clojure форми

:code
  (* 3 7)

  (prn "The sum of 3 and 7"
       " is "
       (+ 3 7))

  (if (> x 0)
    (prn "x > 0")
    (prn "x <= 0"))

  (let [x 3]
    (* x x))

* Имат консистентен вид `(име аргументи)`
* Намира се функцията с подаденото име и се извиква с аргументите
* Обикновено всички аргументи се оценяват преди да бъдат подадени на функцията
* ...но някои форми се държат по специално

= Специални форми

:code
  (let [x 10]
    (* x x))       ; 100

  (if true
    (prn "true")
    (prn "false")) ; "true"

  '(a b c)         ; (a b c)

* По-различни от обикновените форми
* Реализирани са "магически" (в компилатора)
* Не следват нормалните правила за изпълнение
* `def`, `fn`, `if`, `do`, `let`, `quote`, `fn`, .. < 20

= Ядро на езика
== (и какво ни дава компилатора)

* Примитиви
* Специални форми
* Макроси, с които дефинираме "наши специални форми" (spoiler alert!)
* Ядрото на езика (магията) е супер малко в сравнение с други езици
* Всичко останало е на един `(source)` разстояние
* Това е едно от най-големите предимства идващи от Lisp наследството
* Стандартна библиотека е реализирана изцяло на Clojure

= Immutability
== или защо нещата не се променят

* В Clojure immutability-то е по подразбиране
* Всички структури от данни са immutable
* Нямаме mutable променливи в познатия им вид
* Нямаме оператор за присвояване
* Добрия, идиоматичен Clojure код е immutable
* Clojure прави този начин на програмиране максимално ефективен

= Immutability
== на практика

* Нещата се променят и това е неизбежно
* Това трябва да става координирано и на възможно най-малко места
* Опитваме да ограничим страничните ефекти до минимум
* Инструментите за поддържане на състояние в езика се наричат референтни типове

= Данни
== Данни, данни, данни, всичко е данни

{{{<img src="01-intro/data-all-the-things.jpg" width="50%">}}}

= Данни
== Данни, данни, данни, всичко е данни

* Данните естествено се държат в структури от данни
* Имаме едни от най-добрите оръжия да работим с тези структури
* Работим само със сурови данни (не ги крием зад енкапсулации)
* Програмите ни синтезират, преработват и съхраняват данни
* Кода също е данни

= Clojure vs ООП

* Класовете крият данните
* Класовете "заразяват" кода със състояние
* Добрия ООП дизайн е сложна задача
* Разполагаме с други инструменти да правим абстракции и да преизползваме код

= Променливите

* "Указатели" към стойности
* С `def` променяме указателя, а не стойността...
* ...но не го ползваме за промяна
* Предефинирането се ползва основно за интерактивна разработка

= Функциите
== Първокласни обекти в Clojure

* Може да ги създаваме когато си поискаме
* Може да ги държим в стандартните структури от данни
* Може да ги подаваме като аргументи насам-натам
* Може да ги връщаме като резултат от функции

= Функциите

:annotate
  (defn add-1 [n]
    (+ n 1))

  (def add-1 (fn [n] (+ 1 n)))

  [(fn [n] (+ 1 n)) :jam "pineapple"]

  (defn partial
    [f arg1]
    (fn [& args] (apply f arg1 args)))

  (def add-1 (partial + 1))

  (add-1 2) ; =>

* Създаваме анонимни функции с `fn`
* Функциите са първокласни обекти
* `partial` е реализирана в `clojure.core`
* Функции от `clojure.core` са достъпни навсякъде

= Всичко е израз

* Нямаме конструкции
* Всичко връща стойност
* Тази стойност е последното оценено нещо
* Стойността е `nil`, когато няма логика да е друго

= cond
:code
  (defn fib [n]
    (cond
      (= n 0) 1
      (= n 1) 1
      :else (+ (fib (- n 1))
               (fib (- n 2)))))

= case
:code
  (defn fib [n]
    (case n
      0 1
      1 1
      (+ (fib (- n 1))
         (fib (- n 2)))))

= if + няколко неща за правене

:code
  (if (disaster-struck?)
    ((save-laptop) (save-stefan))
    (lick-ice-cream))

Не работи! Ще се опита да използва резултата от `(save-laptop)` като функция и ще му даде като аргумент резултата от `(save-stefan)`.

= do

:code
  (if (disaster-struck?)
    (do
      (save-laptop)
      (save-stefan)
      (save-the-world))
    (lick-ice-cream))

= print форми

В Clojure има два различни начина да обръщате обекти до низ.

:code
  (print [10 "goto 20"]) ; => [10 goto 20]
  (prn [10 "goto 20"])   ; => [10 "goto 20"]

* `(print a)` извежда `(str a)`
* `(println a)` е като `print` с нов ред накрая
* `(pr a)` извежда `(pr-str a)`
* `(prn a)` е като `pr` с нов ред накрая

= when

`when` = `if` + `do` - `else`

:code
  (when (am-grownup? self)
    (walk-naked)
    (lie-all-day)
    (eat-chocolate-all-day)
    (get-fat-all-day)
    (skip-lectures)
    (live-forever))

* `when-not` е като `(when (not ))`.
* `if-not` е като `(if (not ))`.

= nil/truthfulness

Лъжа са само `false` и `nil`:

:annotate
  (defn truth-level [x] (if x "true" "false"))

  (truth-level 5)      ; =>
  (truth-level "baba") ; =>
  (truth-level "")     ; =>
  (truth-level ())     ; =>
  (truth-level [])     ; =>
  (truth-level true)   ; =>
  (truth-level false)  ; =>
  (truth-level nil)    ; =>

= Не е като в Scheme

В Scheme празния списък е `nil`, в Clojure си е просто празен списък. `nil` е всъщност `null` в Java.

= if-let

`if-let` = `if` + `let`

:code
  (if-let [result (parse input)]
    (println "Parsed: " result)
    (println "Parsing failed"))

е еквивалентно на:

:code
  (let [result (parse input)]
    (if result
      (println "Parsed: " result)
      (println "Parsing failed")))

Аналогично: `when-let` = `when` + `let`

= Вектори

* Индексирани колекции с константен достъп до елементите
* Не можем да ги променяме (immutable!)
* Всички "промени" връщат нови вектори

= Вектори

:annotate

  [33 :male "Jerusalem" partial] ; =>
  [1 [2 [3]]]                    ; =>

  (vector 1 2 3)                 ; =>
  (vec '(1 2 3))                 ; =>

= Вектори

:annotate
  (count [1 2 3])               ; =>

  (empty? [])                   ; =>
  (empty? [1 2 3])              ; =>

= Вектори
== Достъп до елементите

:annotate
  (first [1 2 3])                 ; =>
  (second [1 2 3])                ; =>
  (last [1 2 3])                  ; =>

  (nth [1 2 3] 0)                 ; =>
  (nth [1 2 3] 2)                 ; =>
  (nth [1 2 3] 5)                 ; =>
  (nth [1 2 3] 5 "not found")     ; =>

  (get [1 2 3] 2)                 ; =>
  (get [1 2 3] 5)                 ; =>
  (get [1 2 3] 5 "not found")     ; =>

= Вектори
== Добавяне на елементи

:annotate
  (conj [1 2] 3)           ; =>
  (conj [1 2] 3 4 5)       ; =>

  (into [1 2] [3 4 5])     ; =>

  (assoc [-10 0 1 2] 0 -1) ; =>
  (assoc [-10 0 1 2] 8 -1) ; =>

  (let [v [1 2]]
    (vector (conj v 3) v)) ; =>

* Имената на този етап са странни, но всичко ще make-не sense когато видим другите структури.
* Не забравяйте, че тези операции връщат нов вектор, a стария остава непроменен.

= Вектори
== Достъп до елементи

:annotate
  (next [1 2 3])                  ; =>
  (rest [1 2 3])                  ; =>

  (next [])                       ; =>
  (rest [])                       ; =>

  (pop [1 2 3])                   ; =>

  (subvec [1 2 3 4 5 6] 2 4)      ; =>
  (subvec [1 2 3 4 5 6] 2 8)      ; =>
  (subvec [1 2 3 4 5 6] 0 3)      ; =>

= Вектори
== Примери

:annotate
  (defn sum [v]
    (if (empty? v)
      0
      (+ (first v)
         (sum (rest v)))))

  (sum [1 2 3 4 5]) ; =>

= Вектори
== Примери

:annotate
  (defn in-vector? [v x]
    (if (empty? v)
      false
      (or (= (first v) x)
          (in-vector? (rest v) x))))

  (in-vector? [1 2 3] 2) ; =>

= Вектори
== Примери

:annotate
  (defn merge-sorted [v1 v2]
    (if (and (seq v1) (seq v2))
      (if (< (first v1) (first v2))
        (into [(first v1)]
              (merge-sorted (rest v1) v2))
        (into [(first v2)]
              (merge-sorted v1 (rest v2))))
      (if (seq v1) v1 v2)))

  (merge-sorted [1 5 6 14] [2 3 7 9]) ; =>

* `(seq v)` е идиоматичният начин да проверим дали във вектор има елементи
* Ще го ползваме вместо `(not (empty? v))`

= Как да си намерим документация

Очакваме от вас да го правите постоянно. Не разчитайте само на нещата, които ви показваме.

* `(doc if)` `(source when)`
* [Cheatsheet](http://clojure.org/cheatsheet)
* [Style guide](https://github.com/bbatsov/clojure-style-guide)
* [Clojure Programming](http://shop.oreilly.com/product/0636920013754.do)
* [clojure.core](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj)
